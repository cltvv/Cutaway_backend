from datetime import datetime
from typing import Set

from src.profile.models import Profile


class User:
    # boilerplate that could be generated by dataclass decorator
    def __init__(self,
                 id: str,
                 username: str,
                 email: str,
                 hashed_password: str,
                 created_at: datetime = datetime.utcnow(),
                 profiles: Set[Profile] = set()):
        self.id = id
        self.username = username
        self.email = email
        self.created_at = created_at
        self.hashed_password = hashed_password
        self.profiles = profiles

        self.active = self._create_active()
        next(self.active)
        self.blocked = self._create_blocked()
        next(self.blocked)
        self.deactivated = self._create_deactivated()
        next(self.deactivated)

        self.current_state = self.active

    # MARKER 4: eq overrides allow for comparing
    # class instances by their contents,
    # or any arbitrary criteria
    def __eq__(self, other):
        if not isinstance(other, User):
            # avoid doing pointless
            # (and dangerous in dynamic context) comparisons
            return False
        return (
            self.id == other.id and
            self.username == other.username and
            self.email == other.email
        )

    # MARKER 4: this override is needed
    # to use the class instance in dicts and sets,
    # and can be used to early-return out of comparison
    def __hash__(self):
        return hash((self.username, self.email))

    def add_profile(self, profile: Profile):
        if len(self.profiles) >= 10:
            raise ValueError("Profile's limit exceeded")
        self.profiles.add(profile)

    def send(self, command_input):
        self.current_state.send(command_input)
    
    def _create_blocked(self):
        while True:
            command_input = yield
            if command_input == 'unblock':
                self.current_state = self.active
    
    def _create_active(self):
        while True:
            command_input = yield
            if command_input == 'deactivate':
                self.current_state = self.deactivated
            if command_input == 'block':
                self.current_state = self.blocked
    
    def _create_deactivated(self):
        while True:
            command_input = yield
            if command_input == 'activate':
                self.current_state = self.active
    